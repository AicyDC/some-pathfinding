<!DOCTYPE html>
<html>
<head>
	<title>Pixi</title>
	<script src = "pixi.min.js"></script>
	<script src = "VectorsOld.js"></script>
	<script src = "js/Game.js"></script>
	<script src = "js/Grid.js"></script>
	<script src = "js/Agent.js"></script>
	<script src = "js/Steering.js"></script>
</head>
<body>

<script type="text/javascript">

// Start PIXI
let type = "WebGL"
if(!PIXI.utils.isWebGLSupported()){
	type = "canvas"
}

///////////////////////////////////////////////////
////////////////////// PIXI ///////////////////////
///////////////////////////////////////////////////

// Create a Pixi Application
// http://pixijs.download/release/docs/PIXI.Application.html
let app = new PIXI.Application({
width: 1050,         // default: 800
height: 700,        // default: 600
antialias: true,    // default: false
transparent: false, // default: false
resolution: 1       // default: 1
	}
);
// Make the canvas fil the entire window
// app.renderer.view.style.position = "absolute";
// app.renderer.view.style.display = "block";
// app.renderer.autoResize = true;
// app.renderer.resize(window.innerWidth, window.innerHeight);

app.renderer.backgroundColor = 0x061639;
app.renderer.backgroundColor = 0xffffff;

// Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);

///////////////////////////////////////////////////
////////////////////// PIXI ///////////////////////
///////////////////////////////////////////////////

//function that finds adjacent (but not diagonal) cells and returns an array of them
function neighboursOf(vector, grid) {
	var v = vector;
	var x = v.x;
	var y = v.y;
	var neighbours = new Array();

	if (isInBounds(x - 1, y, grid.width, grid.height)) {
		neighbours.push(grid.cells[x - 1][y]);
	} 

	if (isInBounds(x, y - 1, grid.width, grid.height)) {
		neighbours.push(grid.cells[x][y - 1]);
	} 
	if (isInBounds(x + 1, y, grid.width, grid.height)) {
		neighbours.push(grid.cells[x + 1][y]);
	
	} 
	if (isInBounds(x, y + 1, grid.width, grid.height)) {
		neighbours.push(grid.cells[x][y + 1]);
	}
	return neighbours;
}

//Give each cell a distance from the pathEnd using a dijkstra grid
function generateDijkstraGrid(grid, pathEnd) {
	const towers = grid.towers
	//Set all places where towers are as being weight MAXINT, which will stand for not being able to go there
	for (var i = 0; i < towers.length; i++) {
		var t = towers[i];
		grid.cells[t.x][t.y].distance = Number.MAX_VALUE;
	}
	//flood fill from the end point
	pathEnd.distance = 0;

	var toVisit = [pathEnd]; //array which will have more cells added to it

	//for each node we need to visit, starting with the pathEnd
	for (i = 0; i < toVisit.length; i++) {
		var neighbours = neighboursOf(toVisit[i], grid);

		//for each neighbour of this cell
		for (var j = 0; j < neighbours.length; j++) {
			var n = neighbours[j];

			//if unvisted make it's distance the current cell being visted plus one
			if (n.distance == null) {
				n.distance = toVisit[i].distance + 1;
				toVisit.push(n);
			}
		}
	}
}

//Returns the non-obstructed neighbours of the given grid location.
//Diagonals are only included if their neighbours are also not obstructed
function allNeighboursOf(v, cells, gridWidth, gridHeight) {
	var res = [],
		x = v.x,
		y = v.y;

	var left  = isValid(x - 1, y, gridWidth, gridHeight, cells),
		up    = isValid(x, y - 1, gridWidth, gridHeight, cells),
		right = isValid(x + 1, y, gridWidth, gridHeight, cells),
		down  = isValid(x, y + 1, gridWidth, gridHeight, cells);

	//We test each straight direction, then subtest the next one clockwise

	if (left) {
		res.push(cells[x - 1][y]);

		//left up
		if (up && isValid(x - 1, y - 1, gridWidth, gridHeight, cells)) {
			res.push(cells[x - 1][y - 1]);
		}
	}
	if (up) {
		res.push(cells[x][y - 1])

		//up right
		if (right && isValid(x + 1, y- 1, gridWidth, gridHeight, cells)) {
			res.push(cells[x + 1][y - 1]);
		}
	}
	if (right) {
		res.push(cells[x + 1][y])

		//right down
		if (down && isValid(x + 1, y + 1, gridWidth, gridHeight, cells)) {
			res.push(cells[x + 1][y + 1]);
		}
	}
	if (down) {
		res.push(cells[x][y + 1])

		//down left
		if (left && isValid(x - 1, y + 1)) {
			res.push(cells[x - 1][y + 1]);
		}
	}

	return res;
}

function generateFlowField(grid) {
	for (let x = 0; x < grid.width; x++) {
		for (let y = 0; y < grid.height; y++) {

			var cell = grid.cells[x][y]

			//Obstacles have no flow value; leave the direction as the zero vector
			if (cell.distance == Number.MAX_VALUE) {
				continue;
			}

			var neighbours = allNeighboursOf(cell, grid.cells, grid.width, grid.height);

			//Go through all neighbours and find the one with the lowest distance
			var min = null;
			var minDist = 0;
			for (var i = 0; i < neighbours.length; i++) {
				var n = neighbours[i];
				var dist = n.distance - cell.distance;

				if (dist < minDist && n.distance != null) {
					min = n;
					minDist = dist;
				}
			}
			//If we found a valid neighbour, point in its direction
			if (min != null) {
				cell.direction = min.minus(cell).norm();
			}
		}
	}
}

function buildTowers(towers, gridWidth, gridHeight,agents, pathEnd) {
	for (var i = 0; i < 150; i++) {
		var x = parseInt(Math.random()*gridWidth);
		var y = parseInt(Math.random()*gridHeight);
		var validSpot = true;
		//don't place where agents start
		for (var j = 0; j < agents.length; j++) {
			if (agents[j].x == x && agents[j].y == y) {
				validSpot = false;
			}
		}
		//don't place at the destionation
		if (pathEnd.x == x && pathEnd.y == y) {
			validSpot = false;
		}
		if (validSpot) {
			towers.push(new Tower(x, y));
		}
	}
}

function drawGrid(width, height) {
	for ( let x = 0; x < width; x ++) {
        let line = new PIXI.Graphics();
        line.lineStyle(2, 0x000000, 1);
        line.moveTo(x*35, 0);
        line.lineTo(x*35, 20*35);
	    app.stage.addChild(line)
	}
	for (let y = 0; y < height; y++ ) {
		let line = new PIXI.Graphics();
		line.lineStyle(2, 0x000000, 1);
		line.moveTo(0, y*35);
		line.lineTo(width*35, y*35);
		app.stage.addChild(line)
	}
}

function drawTowers(towers) {
	for (i = 0; i < towers.length; i++) {
		let t = towers[i];
		let circle = new PIXI.Graphics();
		circle.beginFill(0x008000);
		circle.drawCircle(t.x*35 + 17.5, t.y*35 + 17.5, 15);
		circle.endFill();
		app.stage.addChild(circle);
	}
}


function drawFlowField(grid) {

for (var x = 0; x < grid.width; x++) {
	for (var y = 0; y < grid.height; y++) {
		f = grid.cells[x][y];
		let line = new PIXI.Graphics();
		line.lineStyle(2, 0x000000, 1);
		line.moveTo(x*35 + 17.5, y*35 + 17.5);
		line.lineTo(x*35 + 17.5 + f.direction.x*17.5, y*35 + 17.5 + f.direction.y*17.5)
		app.stage.addChild(line)
	}
}
}

function setup() {
	game = new Game();
	const gridWidth = 30;
	const gridHeight = 30;
	const grid = new Grid(gridWidth, gridHeight);
	grid.generate_cells();

	const pathEnd = grid.cells[26][10];

	//create agents
	for (var x = 0; x < 2; x++) {
		for (var y = 0; y < 9; y++) {
			game.agents.push(new Agent(3*x + 2, 2*y + 2))
		}
	}
	// console.log(game.agents[0].sprite);
	// game.agents[0].sprite.x = 60;

	buildTowers(grid.towers, gridWidth, gridHeight, game.agents, pathEnd);
	generateDijkstraGrid(grid, pathEnd);
	generateFlowField(grid);

	drawGrid(gridWidth, gridHeight);
	drawFlowField(grid);
	drawTowers(grid.towers);
	// game.draw_agents();

	runAnimation(grid, game);
}

function move_agent(agent, grid) {
	// agent.velocity = new Vector (1,0);
	// let poop = test_boy();
	steeringBehaviourFlowField(agent, grid);
	let flowField = steeringBehaviourFlowField(agent, grid);
	let lowestCost = steeringBehaviourLowestCost(agent, grid); // not sure if working, should not have access function isValid
	var force = (flowField.mul(0.97) ).plus( lowestCost.mul(0.03)); //seems to be pretty perfect with only skipping diagonals 0.25 of a square before the end

	//Apply the force
	agent.velocity = agent.velocity.plus(force);

	//Cap speed as required
	var speed = agent.velocity.magnitude();
	if (speed > agent.maxSpeed) {
		agent.velocity = agent.velocity.mul(agent.maxSpeed/speed);
	}
	//Calculate our new movement angle
	agent.rotation = agent.velocity.angle();

	//Move a bit
	// change agent's pos
	agent.x += agent.velocity.x;
	agent.y += agent.velocity.y;

	// change agent sprite pos
	agent.sprite.x += agent.velocity.x;
	agent.sprite.y += agent.velocity.y;

	// change angent sprite line pos
	// agent.sprite_line.rotation = agent.velocity.angle();
	// agent.sprite_line.x = agent.sprite.x
	// agent.sprite_line.y = agent.sprite.y
}

setup()

function runAnimation(grid, game) {
	gridWidth = 30
	gridHeight = 30 

	for (let i = 0; i < game.agents.length; i++){
		move_agent(game.agents[i], grid);
	}

	requestAnimationFrame(function() {
    	runAnimation(grid, game);
	});
}

</script>

</body>
</html>
